/******************************************************************************
 * This file was generated by langium-cli 0.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, isAstNode } from 'langium';

export type Statement = Assignment | FunctionDefinition | ModuleDefinition | ModuleInstantiation;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface Addition extends AstNode {
    readonly $container: Comparison;
    expr: Array<Multiplication>
}

export const Addition = 'Addition';

export function isAddition(item: unknown): item is Addition {
    return reflection.isInstance(item, Addition);
}

export interface Argument extends AstNode {
    readonly $container: Arguments;
    expr: Expr
    paramName: string
}

export const Argument = 'Argument';

export function isArgument(item: unknown): item is Argument {
    return reflection.isInstance(item, Argument);
}

export interface Arguments extends AstNode {
    readonly $container: Call | Expr | ListComprehensionElements | SingleModuleInstantiation;
    args: Array<Argument>
}

export const Arguments = 'Arguments';

export function isArguments(item: unknown): item is Arguments {
    return reflection.isInstance(item, Arguments);
}

export interface Assignment extends AstNode {
    readonly $container: ChildStatement | ChildStatements | Input | ModuleDefinition;
    name: string
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface Call extends AstNode {
    readonly $container: Exponent;
    args: Array<Arguments>
    expr: Array<Expr>
    id: Array<string>
    part: Array<Primary>
}

export const Call = 'Call';

export function isCall(item: unknown): item is Call {
    return reflection.isInstance(item, Call);
}

export interface ChildStatement extends AstNode {
    readonly $container: ChildStatements | IfStatement | IfelseStatement | ModuleInstantiation;
    block: ChildStatements
    module: ModuleInstantiation
}

export const ChildStatement = 'ChildStatement';

export function isChildStatement(item: unknown): item is ChildStatement {
    return reflection.isInstance(item, ChildStatement);
}

export interface ChildStatements extends AstNode {
    readonly $container: ChildStatement;
    assignements: Array<Assignment>
    stmts: Array<ChildStatement>
}

export const ChildStatements = 'ChildStatements';

export function isChildStatements(item: unknown): item is ChildStatements {
    return reflection.isInstance(item, ChildStatements);
}

export interface Comparison extends AstNode {
    readonly $container: Equality;
    expr: Array<Addition>
}

export const Comparison = 'Comparison';

export function isComparison(item: unknown): item is Comparison {
    return reflection.isInstance(item, Comparison);
}

export interface Equality extends AstNode {
    readonly $container: LogicAnd;
    expr: Array<Comparison>
}

export const Equality = 'Equality';

export function isEquality(item: unknown): item is Equality {
    return reflection.isInstance(item, Equality);
}

export interface Exponent extends AstNode {
    readonly $container: Unary;
    call: Call
    unary: Unary
}

export const Exponent = 'Exponent';

export function isExponent(item: unknown): item is Exponent {
    return reflection.isInstance(item, Exponent);
}

export interface Expr extends AstNode {
    readonly $container: Argument | Call | Expr | FunctionDefinition | IfStatement | ListComprehensionElements | Parameter | Primary;
    args: Arguments
    expr: Expr
    falseExpr: Expr
    or: LogicOr
    parameters: Parameters
    trueExpr: Expr
}

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export interface FunctionDefinition extends AstNode {
    readonly $container: ChildStatement | ChildStatements | Input | ModuleDefinition;
    expr: Expr
    name: string
    params: Parameters
}

export const FunctionDefinition = 'FunctionDefinition';

export function isFunctionDefinition(item: unknown): item is FunctionDefinition {
    return reflection.isInstance(item, FunctionDefinition);
}

export interface IfelseStatement extends AstNode {
    readonly $container: ModuleInstantiation;
    elseBranch: ChildStatement
    ifStmt: IfStatement
}

export const IfelseStatement = 'IfelseStatement';

export function isIfelseStatement(item: unknown): item is IfelseStatement {
    return reflection.isInstance(item, IfelseStatement);
}

export interface IfStatement extends AstNode {
    readonly $container: IfelseStatement;
    body: ChildStatement
    condition: Expr
}

export const IfStatement = 'IfStatement';

export function isIfStatement(item: unknown): item is IfStatement {
    return reflection.isInstance(item, IfStatement);
}

export interface Input extends AstNode {
    statements: Array<Statement>
}

export const Input = 'Input';

export function isInput(item: unknown): item is Input {
    return reflection.isInstance(item, Input);
}

export interface ListComprehensionElements extends AstNode {
    readonly $container: ListComprehensionElementsP;
    args: Arguments
    args2: Arguments
    children: ListComprehensionElementsP
    expr: Expr
    v: Array<VectorElement>
}

export const ListComprehensionElements = 'ListComprehensionElements';

export function isListComprehensionElements(item: unknown): item is ListComprehensionElements {
    return reflection.isInstance(item, ListComprehensionElements);
}

export interface ListComprehensionElementsP extends AstNode {
    readonly $container: ListComprehensionElements | VectorElement;
    e: ListComprehensionElements
}

export const ListComprehensionElementsP = 'ListComprehensionElementsP';

export function isListComprehensionElementsP(item: unknown): item is ListComprehensionElementsP {
    return reflection.isInstance(item, ListComprehensionElementsP);
}

export interface LogicAnd extends AstNode {
    readonly $container: LogicOr;
    expr: Array<Equality>
}

export const LogicAnd = 'LogicAnd';

export function isLogicAnd(item: unknown): item is LogicAnd {
    return reflection.isInstance(item, LogicAnd);
}

export interface LogicOr extends AstNode {
    readonly $container: Expr;
    expr: Array<LogicAnd>
}

export const LogicOr = 'LogicOr';

export function isLogicOr(item: unknown): item is LogicOr {
    return reflection.isInstance(item, LogicOr);
}

export interface ModuleDefinition extends AstNode {
    readonly $container: ChildStatement | ChildStatements | Input | ModuleDefinition;
    body: Statement
    name: string
    params: Parameters
}

export const ModuleDefinition = 'ModuleDefinition';

export function isModuleDefinition(item: unknown): item is ModuleDefinition {
    return reflection.isInstance(item, ModuleDefinition);
}

export interface ModuleId extends AstNode {
    readonly $container: SingleModuleInstantiation;
    id: string
}

export const ModuleId = 'ModuleId';

export function isModuleId(item: unknown): item is ModuleId {
    return reflection.isInstance(item, ModuleId);
}

export interface ModuleInstantiation extends AstNode {
    readonly $container: ChildStatement | ChildStatements | Input | ModuleDefinition;
    child: ChildStatement
    ifElse: IfelseStatement
    module: SingleModuleInstantiation
}

export const ModuleInstantiation = 'ModuleInstantiation';

export function isModuleInstantiation(item: unknown): item is ModuleInstantiation {
    return reflection.isInstance(item, ModuleInstantiation);
}

export interface Multiplication extends AstNode {
    readonly $container: Addition;
    expr: Array<Unary>
}

export const Multiplication = 'Multiplication';

export function isMultiplication(item: unknown): item is Multiplication {
    return reflection.isInstance(item, Multiplication);
}

export interface Parameter extends AstNode {
    readonly $container: Parameters;
    defaultExpr: Expr
    name: string
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface Parameters extends AstNode {
    readonly $container: Expr | FunctionDefinition | ModuleDefinition;
    params: Array<Parameter>
}

export const Parameters = 'Parameters';

export function isParameters(item: unknown): item is Parameters {
    return reflection.isInstance(item, Parameters);
}

export interface Primary extends AstNode {
    readonly $container: Call;
    expr: Expr
    id: string
    number: number
    string: string
    v: VectorElements
}

export const Primary = 'Primary';

export function isPrimary(item: unknown): item is Primary {
    return reflection.isInstance(item, Primary);
}

export interface SingleModuleInstantiation extends AstNode {
    readonly $container: ModuleInstantiation;
    args: Arguments
    id: ModuleId
}

export const SingleModuleInstantiation = 'SingleModuleInstantiation';

export function isSingleModuleInstantiation(item: unknown): item is SingleModuleInstantiation {
    return reflection.isInstance(item, SingleModuleInstantiation);
}

export interface Unary extends AstNode {
    readonly $container: Exponent | Multiplication;
    expr: Exponent
}

export const Unary = 'Unary';

export function isUnary(item: unknown): item is Unary {
    return reflection.isInstance(item, Unary);
}

export interface VectorElement extends AstNode {
    readonly $container: ListComprehensionElements | VectorElements;
    elements: ListComprehensionElementsP
}

export const VectorElement = 'VectorElement';

export function isVectorElement(item: unknown): item is VectorElement {
    return reflection.isInstance(item, VectorElement);
}

export interface VectorElements extends AstNode {
    readonly $container: Primary;
    v: Array<VectorElement>
}

export const VectorElements = 'VectorElements';

export function isVectorElements(item: unknown): item is VectorElements {
    return reflection.isInstance(item, VectorElements);
}

export type OpenScadAstType = 'Addition' | 'Argument' | 'Arguments' | 'Assignment' | 'Call' | 'ChildStatement' | 'ChildStatements' | 'Comparison' | 'Equality' | 'Exponent' | 'Expr' | 'FunctionDefinition' | 'IfStatement' | 'IfelseStatement' | 'Input' | 'ListComprehensionElements' | 'ListComprehensionElementsP' | 'LogicAnd' | 'LogicOr' | 'ModuleDefinition' | 'ModuleId' | 'ModuleInstantiation' | 'Multiplication' | 'Parameter' | 'Parameters' | 'Primary' | 'SingleModuleInstantiation' | 'Statement' | 'Unary' | 'VectorElement' | 'VectorElements';

export type OpenScadAstReference = never;

export class OpenScadAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['Addition', 'Argument', 'Arguments', 'Assignment', 'Call', 'ChildStatement', 'ChildStatements', 'Comparison', 'Equality', 'Exponent', 'Expr', 'FunctionDefinition', 'IfStatement', 'IfelseStatement', 'Input', 'ListComprehensionElements', 'ListComprehensionElementsP', 'LogicAnd', 'LogicOr', 'ModuleDefinition', 'ModuleId', 'ModuleInstantiation', 'Multiplication', 'Parameter', 'Parameters', 'Primary', 'SingleModuleInstantiation', 'Statement', 'Unary', 'VectorElement', 'VectorElements'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case Assignment:
            case FunctionDefinition:
            case ModuleDefinition:
            case ModuleInstantiation: {
                return this.isSubtype(Statement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: OpenScadAstReference): string {
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new OpenScadAstReflection();
